# Parsing Framework 设计说明

本文档面向 **有 2~3 年编程经验的初级工程师**，目标是帮助你：

- 看懂 example 在做什么
- 理解 parsing framework 的设计思路
- 明白为什么这样写「更好维护」

---

## 一、我们要解决什么问题？

假设我们要实现一个计算器：

```text
1 + 2 * (3 + 4) - 5
```

直觉做法通常是：

- 写一个 tokenizer
- 再写 AST
- 再写 visitor
- 再写 evaluator

**问题是：**

- 代码多
- 状态复杂
- 对小工具来说过度设计

而 infra-lite 的目标是：

> **用最少的结构，清晰地完成解析和求值**

---

## 二、核心思想：递归下降（Recursive Descent）

我们先从一个事实开始：

> 表达式是「天然递归」的

例如：

```text
add_sub
 ├── mul_div
 │    ├── number
 │    └── number
 └── mul_div
```

所以代码结构也应该是「递归的」。

---

## 三、ParseResult：消灭全局游标

传统写法常见问题：

```cpp
const char* g_cur;
```

这种方式的问题：

- 不可重入
- 不可测试
- 状态隐藏

### infra-lite 的做法

```cpp
struct ParseResult {
    int value;
    const char* next;
};
```

含义很直观：

- `value`：当前解析结果
- `next` ：下一个未消费的字符位置

**解析函数 = 输入字符串 → 返回 ParseResult**

---

## 四、为什么不需要 AST？

在很多 infra 场景中：

- 我们只关心结果
- 不关心表达式结构

因此：

```text
解析 + 求值 = 一步完成
```

这样可以：

- 减少代码量
- 减少内存分配
- 减少维护成本

---

## 五、chain 的设计动机

观察加减乘除的共同点：

```text
a + b + c
a * b / c
```

它们都是：

- 左结合
- 同一优先级
- 反复出现的模式

### 抽象出来就是：

```cpp
chain(input, sub_parser, '+', '-');
```

含义是：

> 先解析一个子表达式，然后不断吃掉指定运算符

---

## 六、chain 在做什么？

伪代码如下：

```cpp
left = parse_sub()
while (next is operator):
    right = parse_sub()
    left = apply(left, op, right)
```

这正是你手写计算器时脑子里的逻辑。

---

## 七、组合而不是继承

infra-lite 不使用：

- 虚函数
- 类继承
- 复杂层级

而是使用：

- 函数
- 函数指针
- 组合

优点：

- 易读
- 易调试
- 易重构

---

## 八、如何扩展？

### 1️⃣ 增加新运算符

例如 `^`（乘方）：

- 新增一个 `power()` parser
- 用 `chain()` 组合
- 插入到优先级层级中

### 2️⃣ 增加新语法

例如变量：

- 在 `group()` 中识别标识符
- 查符号表
- 返回值

---

## 九、你应该学到什么？

通过这个 framework，你应该学会：

- 如何把问题拆成「递归结构」
- 如何显式传递状态
- 如何做最小抽象
- 什么是「infra 级代码」

---

## 十、最后的话

这个 framework 并不是为了炫技。

它的目标只有一个：

> **让你在几年后回看代码时，依然能看懂**

如果你能完全理解这套设计，
说明你已经开始具备 **基础设施工程师的思维方式**。
